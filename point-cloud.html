<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Virtual Tour with Navigation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
        
        #info {
            position: absolute; top: 10px; width: 100%;
            text-align: center; color: white; font-family: sans-serif;
            z-index: 1;
        }

        /* Full Screen Overlay */
        #image-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none; /* Hidden initially */
            justify-content: center; align-items: center; flex-direction: column;
            z-index: 10;
            opacity: 0; transition: opacity 0.5s ease;
        }

        /* Container for Image + Markers */
        /* We need this relative wrapper to position markers on top of the image */
        #view-container {
            position: relative;
            max-width: 90%;
            max-height: 80%;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }

        #camera-view {
            display: block;
            width: 100%;
            height: auto;
            max-height: 80vh; /* Limit height to viewport */
            border: 2px solid #333;
        }

        /* The Clickable Navigation Dots */
        .nav-marker {
            position: absolute;
            width: 20px; height: 20px;
            background: rgba(255, 255, 255, 0.3); /* Semi-transparent white */
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%); /* Center on coordinate */
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 20;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .nav-marker:hover {
            background: rgba(0, 255, 100, 0.8); /* Green on hover */
            transform: translate(-50%, -50%) scale(1.5);
            box-shadow: 0 0 15px #00ff66;
        }

        /* Tooltip for marker IDs */
        .nav-marker::after {
            content: attr(data-id);
            position: absolute;
            bottom: 25px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white;
            padding: 4px 8px; border-radius: 4px;
            font-size: 12px; white-space: nowrap;
            opacity: 0; pointer-events: none;
            transition: opacity 0.2s;
        }
        .nav-marker:hover::after { opacity: 1; }

        #close-btn {
            margin-top: 20px; padding: 10px 25px;
            background: rgba(255,255,255,0.1); color: white; border: 1px solid white;
            cursor: pointer; font-size: 14px; border-radius: 4px;
            transition: background 0.2s;
        }
        #close-btn:hover { background: rgba(255,255,255,0.3); }

        body.hovering-camera { cursor: pointer; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>
</head>
<body>
    <div id="info">Loading Point Cloud...</div>

    <div id="image-overlay">
        <div id="view-container">
            <img id="camera-view" src="" alt="Camera View">
            <div id="marker-layer"></div> </div>
        <button id="close-btn">Return to 3D View</button>
    </div>

    <script src="results/panorama_results.js" type="application/javascript"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
        import gsap from 'gsap';

        // --- GLOBAL VARIABLES ---
        let cameraOffset = new THREE.Vector3(); 
        const cameraMarkers = []; 
        const worldGroup = new THREE.Group(); 
        
        // Fast lookup map to find camera data by ID (key: id, value: {data, mesh})
        const cameraMap = new Map(); 

        // 1. Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        scene.add(worldGroup);
        worldGroup.rotation.x = -Math.PI;
        worldGroup.rotation.y = -0.6;

        // 2. Load PLY
        const loader = new PLYLoader();
        loader.load('./results/point_cloud_after_ba.ply', function (geometry) {
            geometry.computeBoundingSphere();
            const center = geometry.boundingSphere.center;
            cameraOffset.copy(center).multiplyScalar(-1); 
            geometry.translate(cameraOffset.x, cameraOffset.y, cameraOffset.z);

            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: geometry.hasAttribute('color'),
            });

            const pointCloud = new THREE.Points(geometry, material);
            worldGroup.add(pointCloud);

            document.getElementById('info').innerHTML = "Click red spheres or use image navigation. Double-click point cloud to jump to best view. <a href='./home.html' style='color: #0000ff;'>Go to Panorama Tour</a>";

            initPreciseCameras();

        }, undefined, (err) => document.getElementById('info').innerText = "Error loading PLY.");

        // 3. Helper: Math for Cameras
        function getCameraPoseFromRt(R, t) {
            const matrix = new THREE.Matrix4();
            matrix.set(
                R[0][0], R[0][1], R[0][2], t[0],
                R[1][0], R[1][1], R[1][2], t[1],
                R[2][0], R[2][1], R[2][2], t[2],
                0,       0,       0,       1
            );
            const pose = matrix.invert();
            pose.multiply(new THREE.Matrix4().makeScale(1, -1, -1)); // CV to Three.js conversion
            return pose;
        }

        // 4. Initialize Cameras
        function initPreciseCameras() {
            const locations = cameraLocations || []; 
            if(locations.length === 0) return;

            const markerGeo = new THREE.SphereGeometry(0.15, 16, 16);
            const markerMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            locations.forEach(data => {
                if (data.R && data.t) {
                    const poseMatrix = getCameraPoseFromRt(data.R, data.t);
                    const mesh = new THREE.Mesh(markerGeo, markerMat);
                    
                    mesh.applyMatrix4(poseMatrix);
                    mesh.position.add(cameraOffset);

                    // Store full data object in mesh for easy access
                    mesh.userData = data;

                    worldGroup.add(mesh);
                    cameraMarkers.push(mesh);

                    // Add to map for ID lookup
                    cameraMap.set(data.id, { data: data, mesh: mesh });
                }
            });
        }

        // --- INTERACTION: 3D Scene ---
        
        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(cameraMarkers);
            document.body.classList.toggle('hovering-camera', intersects.length > 0);
        });

        window.addEventListener('click', (event) => {
            // Prevent 3D clicks if overlay is visible
            if(document.getElementById('image-overlay').style.display === 'flex') return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cameraMarkers);

            if (intersects.length > 0) {
                // Start transition
                enterCameraView(intersects[0].object);
            }
        });

        window.addEventListener('dblclick', (event) => {
            // Prevent 3D clicks if overlay is visible
            if(document.getElementById('image-overlay').style.display === 'flex') return;

            raycaster.setFromCamera(mouse, camera);
            
            // Try to intersect with the point cloud
            const pointCloudIntersects = raycaster.intersectObjects(worldGroup.children, true);
            
            if (pointCloudIntersects.length > 0) {
                const clickedPoint = pointCloudIntersects[0].point;
                const bestCamera = findBestCameraForPoint(clickedPoint);
                
                if (bestCamera) {
                    enterCameraView(bestCamera);
                }
            }
        });

        function findBestCameraForPoint(point) {
            if (cameraMarkers.length === 0) return null;

            let bestCamera = null;
            let bestScore = Infinity;

            cameraMarkers.forEach(marker => {
                // Get camera position in world space
                const cameraPos = new THREE.Vector3();
                marker.getWorldPosition(cameraPos);

                // Get camera orientation in world space
                const cameraQuat = new THREE.Quaternion();
                marker.getWorldQuaternion(cameraQuat);

                // Calculate vector from camera to point
                const toPoint = point.clone().sub(cameraPos);
                const distance = toPoint.length();

                // Get camera forward direction (Three.js cameras look down -Z)
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(cameraQuat);

                // Calculate if point is in front of camera
                const dotProduct = toPoint.normalize().dot(forward);

                // Point should be in front (dotProduct > 0) and visible (roughly in view cone)
                // cos(60°) ≈ 0.5 for a reasonable field of view
                const isVisible = dotProduct > 0.3;

                if (isVisible) {
                    // Score: lower is better (prioritize closer cameras with better alignment)
                    // Weight distance heavily but also consider viewing angle
                    const score = distance * (2 - dotProduct);
                    
                    if (score < bestScore) {
                        bestScore = score;
                        bestCamera = marker;
                    }
                }
            });

            return bestCamera;
        }

        // --- ANIMATION: Fly to Camera ---
        function enterCameraView(targetMesh) {
            controls.enabled = false;

            // 1. Hide Overlay (if moving between images)
            const overlay = document.getElementById('image-overlay');
            overlay.style.opacity = '0';
            // Hide existing image
            // overlayImg.src = '';

            // 2. Get World Transform
            const targetPos = new THREE.Vector3();
            const targetQuat = new THREE.Quaternion();
            targetMesh.getWorldPosition(targetPos);
            targetMesh.getWorldQuaternion(targetQuat);

            // 3. GSAP Animation
            const timeline = gsap.timeline({
                onComplete: () => {
                    // Show the overlay for this specific camera data
                    showOverlay(targetMesh.userData);
                }
            });

            // Position
            timeline.to(camera.position, {
                duration: 1.5,
                x: targetPos.x, y: targetPos.y, z: targetPos.z,
                ease: "power2.inOut"
            }, 0);

            // Rotation
            const startQuat = camera.quaternion.clone();
            const dummy = { t: 0 };
            timeline.to(dummy, {
                duration: 1.5, t: 1, ease: "power2.inOut",
                onUpdate: () => camera.quaternion.slerpQuaternions(startQuat, targetQuat, dummy.t)
            }, 0);

            // Orbit Target (Look slightly forward)
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(targetQuat);
            const lookTarget = targetPos.clone().add(forward);
            gsap.to(controls.target, {
                duration: 1.5,
                x: lookTarget.x, y: lookTarget.y, z: lookTarget.z
            }, 0);
        }

        // --- OVERLAY: Image & Navigation Logic ---
        
        const overlay = document.getElementById('image-overlay');
        const overlayImg = document.getElementById('camera-view');
        const markerLayer = document.getElementById('marker-layer');
        const closeBtn = document.getElementById('close-btn');

        function showOverlay(cameraData) {
            overlayImg.src = cameraData.image;
            
            // Clear old markers
            markerLayer.innerHTML = ''; 

            // IMPORTANT: Wait for image to load to get dimensions for positioning
            overlayImg.onload = () => {
                renderNavigationMarkers(cameraData, overlayImg.naturalWidth, overlayImg.naturalHeight);
            };

            // If image is cached/already loaded, trigger immediately
            if (overlayImg.complete && overlayImg.naturalWidth > 0) {
                 renderNavigationMarkers(cameraData, overlayImg.naturalWidth, overlayImg.naturalHeight);
            }

            overlay.style.display = 'flex';
            setTimeout(() => overlay.style.opacity = '1', 50);
        }

        function renderNavigationMarkers(cameraData, imgWidth, imgHeight) {
            if (!cameraData.other_cameras) return;

            cameraData.other_cameras.forEach(other => {
                // Ensure the camera is marked as visible and we have its ID in our scene
                if (other.visible && cameraMap.has(other.id)) {
                    
                    // Convert Pixel Coordinates to Percentage (Responsive)
                    // The CSS container is relative, so left: 50% puts it in the middle regardless of screen size
                    const leftPct = (other.pixel_location[0] / imgWidth) * 100;
                    const topPct = (other.pixel_location[1] / imgHeight) * 100;

                    const marker = document.createElement('div');
                    marker.className = 'nav-marker';
                    marker.style.left = `${leftPct}%`;
                    marker.style.top = `${topPct}%`;
                    marker.dataset.id = other.id; // For tooltip

                    // Interaction: Click to fly to next camera
                    marker.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent bubbling
                        navigateToNextCamera(other.id);
                    });

                    markerLayer.appendChild(marker);
                }
            });
        }

        function navigateToNextCamera(targetId) {
            const target = cameraMap.get(targetId);
            if (target) {
                // Trigger the full 3D transition logic
                // This fades out current overlay, flies camera, fades in new overlay
                enterCameraView(target.mesh);
            }
        }

        // Close Button Logic
        closeBtn.addEventListener('click', () => {
            overlay.style.opacity = '0';
            setTimeout(() => {
                overlay.style.display = 'none';
                overlayImg.src = '';
                markerLayer.innerHTML = '';
                controls.enabled = true;
            }, 500);
        });

        // Resize Loop
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

    </script>
</body>
</html>